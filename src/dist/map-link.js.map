{"version":3,"file":"map-link.js","sources":["../src/map-link.js"],"sourcesContent":["/* global M */\n\nexport class MapLink extends HTMLElement {\n  static get observedAttributes() {\n    return [\n      'type',\n      'rel',\n      //      'title',\n      'media',\n      'href',\n      'hreflang',\n      'tref',\n      'tms',\n      'projection'\n    ];\n  }\n  /* jshint ignore:start */\n  #hasConnected;\n  /* jshint ignore:end */\n  get type() {\n    return this.getAttribute('type') || 'image/*';\n  }\n  set type(val) {\n    // improve this\n    if (val === 'text/mapml' || val.startsWith('image/')) {\n      this.setAttribute('type', val);\n    }\n  }\n  get rel() {\n    // rel value has no default value\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel#:~:text=The%20rel%20attribute%20has%20no%20default%20value.\n    return this.getAttribute('rel');\n  }\n  set rel(val) {\n    // improve this\n    if (\n      [\n        'license',\n        'alternate',\n        'self',\n        'style',\n        'tile',\n        'image',\n        'features',\n        'zoomin',\n        'zoomout',\n        'legend',\n        'query',\n        'stylesheet'\n      ].includes(val)\n    ) {\n      this.setAttribute('type', val);\n    }\n  }\n  //  get title() {\n  //    return this.getAttribute('title');\n  //  }\n  //  set title(val) {\n  //    if (val) {\n  //      this.setAttribute('title', val);\n  //    }\n  //  }\n  get href() {\n    if (this.hasAttribute('href')) {\n      return new URL(this.getAttribute('href'), this.getBase()).href;\n    } else if (this.hasAttribute('tref')) {\n      return this.resolve();\n    }\n  }\n  set href(val) {\n    // improve this\n    if (val) {\n      this.setAttribute('href', val);\n    }\n  }\n  get hreflang() {\n    return this.getAttribute('hreflang');\n  }\n  set hreflang(val) {\n    // improve this\n    if (val) {\n      this.setAttribute('hreflang', val);\n    }\n  }\n  get tref() {\n    if (!this.hasAttribute('tref')) {\n      return M.BLANK_TT_TREF;\n    }\n    return this.getAttribute('tref');\n  }\n  set tref(val) {\n    // improve this\n    if (val) {\n      this.setAttribute('tref', val);\n    }\n  }\n  get media() {\n    // return the content of media attribute as an object\n    // maybe memoizing the object to avoid repeated formatting\n    // the Util function may need to be renamed?\n    return M._metaContentToObject(this.getAttribute('media'));\n  }\n  set media(val) {\n    this.setAttribute('media', val);\n  }\n  get tms() {\n    return this.hasAttribute('tms');\n  }\n  set tms(val) {\n    // improve this\n    if (val) {\n      this.setAttribute('tms', '');\n    }\n  }\n  get projection() {\n    return this.getAttribute('projection');\n  }\n  set projection(val) {\n    // improve this\n    if (['OSMTILE', 'CBMTILE', 'WGS84', 'APSTILE'].includes(val)) {\n      this.setAttribute('projection', val);\n    }\n  }\n  get extent() {\n    // calculate the bounds of content, return it.\n    // _templateVars existence happens for both templated layers and query links\n    return this._templateVars\n      ? Object.assign(\n          M._convertAndFormatPCRS(\n            this.getBounds(),\n            M[this.parentExtent.units],\n            this.parentExtent.units\n          ),\n          { zoom: this.getZoomBounds() }\n        )\n      : null;\n  }\n  zoomTo() {\n    let extent = this.extent;\n    if (!extent) return;\n    let map = this.getMapEl()._map,\n      xmin = extent.topLeft.pcrs.horizontal,\n      xmax = extent.bottomRight.pcrs.horizontal,\n      ymin = extent.bottomRight.pcrs.vertical,\n      ymax = extent.topLeft.pcrs.vertical,\n      bounds = L.bounds(L.point(xmin, ymin), L.point(xmax, ymax)),\n      center = map.options.crs.unproject(bounds.getCenter(true)),\n      maxZoom = extent.zoom.maxZoom,\n      minZoom = extent.zoom.minZoom;\n    map.setView(center, M.getMaxZoom(bounds, map, minZoom, maxZoom), {\n      animate: false\n    });\n  }\n  getClosest(node, selector) {\n    if (!node) {\n      return null;\n    }\n    if (node instanceof ShadowRoot) {\n      return this.getClosest(node.host, selector);\n    }\n\n    if (node instanceof HTMLElement) {\n      if (node.matches(selector)) {\n        return node;\n      } else {\n        return this.getClosest(node.parentNode, selector);\n      }\n    }\n\n    return this.getClosest(node.parentNode, selector);\n  }\n  getMapEl() {\n    return this.getClosest(this, 'mapml-viewer,map[is=web-map]');\n  }\n  getLayerEl() {\n    return this.getClosest(this, 'layer-');\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    //['type','rel','href','hreflang','tref','tms','projection'];\n    // fold to lowercase\n    if (this.#hasConnected /* jshint ignore:line */) {\n      switch (name) {\n        case 'type':\n          // rel = tile, features, etc. TBD when it is used\n          //        ttype = !t.hasAttribute('type')\n          //          ? 'image/*'\n          //          : t.getAttribute('type').toLowerCase(),\n\n          if (oldValue !== newValue) {\n            // default value image/*\n            // handle side effects\n          }\n          break;\n        case 'rel':\n          // mandatory attribute, no default value\n          if (oldValue !== newValue) {\n            // handle side effects\n            if (newValue === 'query') {\n            }\n          }\n          break;\n        //      case 'title':\n        //        if (oldValue !== newValue) {\n        //          // handle side effects\n        //        }\n        //        break;\n        case 'href':\n          // rel = license, legend, stylesheet, self, style, self style, style self, zoomin, zoomout\n          if (oldValue !== newValue) {\n            // handle side effects\n          }\n          break;\n        case 'hreflang':\n          // rel = *all*\n          // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#hreflang\n          // idea is that we can have multiple map-links with different hreflang, and map-extent chooses a map-link that matches with user's lang. Not a priority. - create an use-case issue?\n          if (oldValue !== newValue) {\n            // handle side effects\n          }\n          break;\n        case 'tref':\n          // rel = tile, image, features, query\n          if (oldValue !== newValue) {\n            // create or reset the _templateVars property\n            this._initTemplateVars();\n          }\n          break;\n        case 'media':\n          break;\n        case 'tms':\n          // rel = tile\n          if (oldValue !== newValue) {\n            // handle side effects\n          }\n          break;\n        case 'projection':\n          // rel = alternate\n          if (oldValue !== newValue) {\n            // handle side effects\n          }\n          break;\n      }\n    }\n  }\n  constructor() {\n    // Always call super first in constructor\n    super();\n  }\n  connectedCallback() {\n    this.#hasConnected = true; /* jshint ignore:line */\n    if (\n      this.getLayerEl().hasAttribute('data-moving') ||\n      (this.parentExtent && this.parentExtent.hasAttribute('data-moving'))\n    )\n      return;\n    switch (this.rel.toLowerCase()) {\n      // for some cases, require a dependency check\n      case 'tile':\n      case 'image':\n      case 'features':\n      case 'query':\n        this._initTemplateVars();\n        this._createTemplatedLink();\n        break;\n      case 'style':\n      case 'self':\n      case 'style self':\n      case 'self style':\n        this._createSelfOrStyleLink();\n        break;\n      case 'zoomin':\n      case 'zoomout':\n        //        this._createZoominOrZoomoutLink();\n        break;\n      case 'legend':\n        //this._createLegendLink();\n        break;\n      case 'stylesheet':\n        this._createStylesheetLink();\n        break;\n      case 'alternate':\n        this._createAlternateLink(); // add media attribute\n        break;\n      case 'license':\n        // this._createLicenseLink();\n        break;\n    }\n    // create the type of templated leaflet layer appropriate to the rel value\n    // image/map/features = templated(Image/Feature), tile=templatedTile,\n    // this._tempatedTileLayer = M.templatedTile(pane: this.extentElement._leafletLayer._container)\n    // add to viewer._map dependant on map-extent.checked, layer-.checked\n    // what else?\n  }\n  disconnectedCallback() {\n    switch (this.rel.toLowerCase()) {\n      case 'stylesheet':\n        if (this._stylesheetHost) {\n          this.link.remove();\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  _createAlternateLink(mapml) {\n    if (this.href && this.projection) this._alternate = true;\n  }\n  _createStylesheetLink() {\n    // if the parent element is a map-link, the stylesheet is a link that should\n    //  be loaded as part of a templated layer processing i.e. on moveend\n    //  and the generated <link> that implements this <map-link> should be located\n    //  in the parent <map-link>._templatedLayer.container root node if\n    //  the _templatedLayer is an instance of M.TemplatedTileLayer or M.TemplatedFeaturesLayer\n    //\n    // if the parent node (or the host of the shadow root parent node) is layer-, the link should be created in the _layer\n    // container\n    this._stylesheetHost =\n      this.getRootNode() instanceof ShadowRoot\n        ? this.getRootNode().host\n        : this.parentElement;\n    if (this._stylesheetHost === undefined) return;\n\n    this.link = document.createElement('link');\n    this.link.mapLink = this;\n    this.link.setAttribute('href', new URL(this.href, this.getBase()).href);\n    copyAttributes(this, this.link);\n\n    if (this._stylesheetHost._layer) {\n      this._stylesheetHost._layer.appendStyleLink(this);\n    } else if (this._stylesheetHost._templatedLayer) {\n      this._stylesheetHost._templatedLayer.appendStyleLink(this);\n    }\n\n    function copyAttributes(source, target) {\n      return Array.from(source.attributes).forEach((attribute) => {\n        if (attribute.nodeName !== 'href')\n          target.setAttribute(attribute.nodeName, attribute.nodeValue);\n      });\n    }\n  }\n\n  async _createTemplatedLink() {\n    // conditions check\n    // the tms and type attributes are optional, may need to be checked in future\n    this.parentExtent =\n      this.parentNode.nodeName.toUpperCase() === 'MAP-EXTENT'\n        ? this.parentNode\n        : this.parentNode.host;\n    if (!this.tref || !this.parentExtent) return;\n    try {\n      await this.parentExtent.whenReady();\n      await this._templateVars.inputsReady;\n    } catch (error) {\n      console.log('Error while creating templated link: ' + error);\n      return;\n    }\n    this.mapEl = this.getMapEl();\n    // create the layer type appropriate to the rel value\n    this.zIndex = Array.from(\n      this.parentExtent.querySelectorAll(\n        'map-link[rel=image],map-link[rel=tile],map-link[rel=features]'\n      )\n    ).indexOf(this);\n    if (this.rel === 'tile') {\n      this._templatedLayer = M.templatedTileLayer(this._templateVars, {\n        zoomBounds: this.getZoomBounds(),\n        extentBounds: this.getBounds(),\n        crs: M[this.parentExtent.units],\n        errorTileUrl:\n          'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==',\n        zIndex: this.zIndex,\n        pane: this.parentExtent._extentLayer.getContainer(),\n        linkEl: this\n      }).addTo(this.parentExtent._extentLayer);\n    } else if (this.rel === 'image') {\n      this._templatedLayer = M.templatedImageLayer(this._templateVars, {\n        zoomBounds: this.getZoomBounds(),\n        extentBounds: this.getBounds(),\n        zIndex: this.zIndex,\n        pane: this.parentExtent._extentLayer.getContainer(),\n        linkEl: this\n      }).addTo(this.parentExtent._extentLayer);\n    } else if (this.rel === 'features') {\n      // map-feature retrieved by link will be stored in shadowRoot owned by link\n      this.attachShadow({ mode: 'open' });\n      this._templatedLayer = M.templatedFeaturesLayer(this._templateVars, {\n        zoomBounds: this.getZoomBounds(),\n        extentBounds: this.getBounds(),\n        zIndex: this.zIndex,\n        pane: this.parentExtent._extentLayer.getContainer(),\n        linkEl: this\n      }).addTo(this.parentExtent._extentLayer);\n    } else if (this.rel === 'query') {\n      this.attachShadow({ mode: 'open' });\n      L.extend(this._templateVars, this._setupQueryVars(this._templateVars));\n      L.extend(this._templateVars, { extentBounds: this.getBounds() });\n    }\n  }\n  _setupQueryVars(template) {\n    // process the inputs associated to template and create an object named\n    // query with member properties as follows:\n    // {width: 'widthvarname',\n    //  height: 'heightvarname',\n    //  left: 'leftvarname',\n    //  right: 'rightvarname',\n    //  top: 'topvarname',\n    //  bottom: 'bottomvarname'\n    //  i: 'ivarname'\n    //  j: 'jvarname'}\n    //  x: 'xvarname' x being the tcrs x axis\n    //  y: 'yvarname' y being the tcrs y axis\n    //  z: 'zvarname' zoom\n    //  title: link title\n\n    var queryVarNames = { query: {} },\n      inputs = template.values;\n\n    for (var i = 0; i < template.values.length; i++) {\n      var type = inputs[i].getAttribute('type'),\n        units = inputs[i].getAttribute('units'),\n        axis = inputs[i].getAttribute('axis'),\n        name = inputs[i].getAttribute('name'),\n        position = inputs[i].getAttribute('position'),\n        rel = inputs[i].getAttribute('rel'),\n        select = inputs[i].tagName.toLowerCase() === 'map-select';\n      if (type === 'width') {\n        queryVarNames.query.width = name;\n      } else if (type === 'height') {\n        queryVarNames.query.height = name;\n      } else if (type === 'location') {\n        switch (axis) {\n          case 'x':\n          case 'y':\n          case 'column':\n          case 'row':\n            queryVarNames.query[axis] = name;\n            break;\n          case 'longitude':\n          case 'easting':\n            if (position) {\n              if (position.match(/.*?-left/i)) {\n                if (rel === 'pixel') {\n                  queryVarNames.query.pixelleft = name;\n                } else if (rel === 'tile') {\n                  queryVarNames.query.tileleft = name;\n                } else {\n                  queryVarNames.query.mapleft = name;\n                }\n              } else if (position.match(/.*?-right/i)) {\n                if (rel === 'pixel') {\n                  queryVarNames.query.pixelright = name;\n                } else if (rel === 'tile') {\n                  queryVarNames.query.tileright = name;\n                } else {\n                  queryVarNames.query.mapright = name;\n                }\n              }\n            } else {\n              queryVarNames.query[axis] = name;\n            }\n            break;\n          case 'latitude':\n          case 'northing':\n            if (position) {\n              if (position.match(/top-.*?/i)) {\n                if (rel === 'pixel') {\n                  queryVarNames.query.pixeltop = name;\n                } else if (rel === 'tile') {\n                  queryVarNames.query.tiletop = name;\n                } else {\n                  queryVarNames.query.maptop = name;\n                }\n              } else if (position.match(/bottom-.*?/i)) {\n                if (rel === 'pixel') {\n                  queryVarNames.query.pixelbottom = name;\n                } else if (rel === 'tile') {\n                  queryVarNames.query.tilebottom = name;\n                } else {\n                  queryVarNames.query.mapbottom = name;\n                }\n              }\n            } else {\n              queryVarNames.query[axis] = name;\n            }\n            break;\n          case 'i':\n            if (units === 'tile') {\n              queryVarNames.query.tilei = name;\n            } else {\n              queryVarNames.query.mapi = name;\n            }\n            break;\n          case 'j':\n            if (units === 'tile') {\n              queryVarNames.query.tilej = name;\n            } else {\n              queryVarNames.query.mapj = name;\n            }\n            break;\n          default:\n          // unsuportted axis value\n        }\n      } else if (type === 'zoom') {\n        //<input name=\"...\" type=\"zoom\" value=\"0\" min=\"0\" max=\"17\">\n        queryVarNames.query.zoom = name;\n      } else if (select) {\n        /*jshint -W104 */\n        const parsedselect = inputs[i].htmlselect;\n        queryVarNames.query[name] = function () {\n          return parsedselect.value;\n        };\n      } else {\n        /*jshint -W104 */\n        const input = inputs[i];\n        queryVarNames.query[name] = function () {\n          return input.getAttribute('value');\n        };\n      }\n    }\n    return queryVarNames;\n  }\n  _initTemplateVars() {\n    // set up the URL template and associated inputs (which yield variable values when processed)\n    var varNamesRe = new RegExp('(?:{)(.*?)(?:})', 'g'),\n      zoomInput = this.parentElement.querySelector('map-input[type=\"zoom\" i]'),\n      includesZoom = false,\n      linkedZoomInput;\n\n    var template = this.tref;\n    if (template === M.BLANK_TT_TREF) {\n      for (let i of this.parentElement.querySelectorAll('map-input')) {\n        template += `{${i.getAttribute('name')}}`;\n      }\n    }\n    this.zoomInput = zoomInput;\n\n    var v,\n      vcount = template.match(varNamesRe) || [],\n      inputs = [],\n      inputsReady = [];\n    while ((v = varNamesRe.exec(template)) !== null) {\n      let varName = v[1],\n        inp = this.parentElement.querySelector(\n          'map-input[name=' + varName + '],map-select[name=' + varName + ']'\n        );\n      if (inp) {\n        // this \"associates\" the input to this  map-link\n        inputs.push(inp);\n        inputsReady.push(inp.whenReady());\n\n        // I think this means that regardless of whether the tref includes\n        // a reference to the zoom input, it gets associated to the link\n        // and used (to specify the native zoom bounds??) for the templated(Tile|Image|Features)Layer\n        if (\n          inp.hasAttribute('type') &&\n          inp.getAttribute('type').toLowerCase() === 'zoom'\n        ) {\n          linkedZoomInput = inp;\n          includesZoom = true;\n        }\n        // moved a block to map-select to transcribe the map-select into an\n        // actual html select for inclusion in the layer control.\n\n        // TODO: if this is an input@type=location\n        // get the TCRS min,max attribute values at the identified zoom level\n        // save this information as properties of the mapExtent,\n        // perhaps as a bounds object so that it can be easily used\n        // later by the layer control to determine when to enable\n        // disable the layer for drawing.\n      } else {\n        console.log(\n          'input with name=' +\n            varName +\n            ' not found for template variable of same name'\n        );\n      }\n    }\n    if (template && vcount.length === inputs.length) {\n      if (!includesZoom && zoomInput) {\n        inputs.push(zoomInput);\n        linkedZoomInput = zoomInput;\n      }\n      let step = zoomInput ? zoomInput.getAttribute('step') : 1;\n      if (!step || step === '0' || isNaN(step)) step = 1;\n      // template has a matching input for every variable reference {varref}\n      this._templateVars = {\n        template: decodeURI(new URL(template, this.getBase())),\n        linkEl: this,\n        rel: this.rel,\n        type: this.type,\n        values: inputs,\n        inputsReady: Promise.allSettled(inputsReady),\n        zoom: linkedZoomInput,\n        projection: this.parentElement.units,\n        tms: this.tms,\n        step: step\n      };\n    }\n  }\n  getZoomBounds() {\n    return this._getZoomBounds(this._templateVars.zoom);\n  }\n  /**\n   * TODO: review getBounds for sanity, also getFallbackBounds, perhaps integrate\n   * there is no other kind of bounds but native....\n   *  each rectangle must be established and valid and converted to PCRS coordinates...\n    // \"native\" bounds = input type=location min max || map-extent/map-meta name=extent min,max || layer-/map-meta name=extent min,max || layer projection min/max\n */\n  getBounds() {\n    let template = this._templateVars;\n    let inputs = template.values,\n      projection = this.parentElement.units,\n      boundsUnit = {};\n    boundsUnit.name = M.FALLBACK_CS;\n    let bounds = M[projection].options.crs.tilematrix.bounds(0),\n      locInputs = false,\n      numberOfAxes = 0,\n      horizontalAxis = false,\n      verticalAxis = false;\n    for (let i = 0; i < inputs.length; i++) {\n      if (inputs[i].getAttribute('type') === 'location') {\n        if (!inputs[i].getAttribute('max') || !inputs[i].getAttribute('min'))\n          continue;\n        let max = +inputs[i].getAttribute('max'),\n          min = +inputs[i].getAttribute('min');\n        switch (inputs[i].getAttribute('axis').toLowerCase()) {\n          case 'x':\n          case 'longitude':\n          case 'column':\n          case 'easting':\n            boundsUnit.name = M.axisToCS(\n              inputs[i].getAttribute('axis').toLowerCase()\n            );\n            bounds.min.x = min;\n            bounds.max.x = max;\n            boundsUnit.horizontalAxis = inputs[i]\n              .getAttribute('axis')\n              .toLowerCase();\n            break;\n          case 'y':\n          case 'latitude':\n          case 'row':\n          case 'northing':\n            boundsUnit.name = M.axisToCS(\n              inputs[i].getAttribute('axis').toLowerCase()\n            );\n            bounds.min.y = min;\n            bounds.max.y = max;\n            boundsUnit.verticalAxis = inputs[i]\n              .getAttribute('axis')\n              .toLowerCase();\n            break;\n          default:\n            break;\n        }\n      }\n    }\n    if (\n      boundsUnit.horizontalAxis &&\n      boundsUnit.verticalAxis &&\n      ((boundsUnit.horizontalAxis === 'x' && boundsUnit.verticalAxis === 'y') ||\n        (boundsUnit.horizontalAxis === 'longitude' &&\n          boundsUnit.verticalAxis === 'latitude') ||\n        (boundsUnit.horizontalAxis === 'column' &&\n          boundsUnit.verticalAxis === 'row') ||\n        (boundsUnit.horizontalAxis === 'easting' &&\n          boundsUnit.verticalAxis === 'northing'))\n    ) {\n      locInputs = true;\n    }\n    if (locInputs) {\n      let zoomValue = this._templateVars.zoom?.hasAttribute('value')\n        ? +this._templateVars.zoom.getAttribute('value')\n        : 0;\n      bounds = M.boundsToPCRSBounds(\n        bounds,\n        zoomValue,\n        projection,\n        boundsUnit.name\n      );\n    } else if (!locInputs) {\n      bounds = this.getFallbackBounds(projection);\n    }\n    return bounds;\n  }\n  getFallbackBounds(projection) {\n    let bounds;\n\n    let zoom = 0;\n    let metaExtent = this.parentElement.getMeta('extent');\n    if (metaExtent) {\n      let content = M._metaContentToObject(metaExtent.getAttribute('content')),\n        cs;\n\n      zoom = content.zoom || zoom;\n\n      let metaKeys = Object.keys(content);\n      for (let i = 0; i < metaKeys.length; i++) {\n        if (!metaKeys[i].includes('zoom')) {\n          cs = M.axisToCS(metaKeys[i].split('-')[2]);\n          break;\n        }\n      }\n      let axes = M.csToAxes(cs);\n      bounds = M.boundsToPCRSBounds(\n        L.bounds(\n          L.point(\n            +content[`top-left-${axes[0]}`],\n            +content[`top-left-${axes[1]}`]\n          ),\n          L.point(\n            +content[`bottom-right-${axes[0]}`],\n            +content[`bottom-right-${axes[1]}`]\n          )\n        ),\n        zoom,\n        projection,\n        cs\n      );\n    } else {\n      let crs = M[projection];\n      bounds = crs.options.crs.pcrs.bounds;\n    }\n    return bounds;\n  }\n  getBase() {\n    let layer = this.getRootNode().host;\n    //\n    let relativeURL =\n      this.getRootNode().querySelector('map-base') &&\n      this.getRootNode() instanceof ShadowRoot\n        ? this.getRootNode().querySelector('map-base').getAttribute('href')\n        : /* local content? */ !(this.getRootNode() instanceof ShadowRoot)\n        ? /* use the baseURI algorithm which takes into account any <base> */\n          this.getRootNode().querySelector('map-base')?.getAttribute('href') ||\n          this.baseURI\n        : /* else use the resolved <layer- src=\"...\"> value */ new URL(\n            layer.src,\n            layer.baseURI\n          ).href;\n\n    // when remote content, use layer.src as base else use baseURI of map-link\n    let baseURL =\n      this.getRootNode() instanceof ShadowRoot\n        ? new URL(layer.src, layer.baseURI).href\n        : this.baseURI;\n    return new URL(relativeURL, baseURL).href;\n  }\n  /**\n   * Return BOTH min/max(Display)Zoom AND min/maxNativeZoom which\n   * are options that can be passed to L.GridLayer...\n   * https://leafletjs.com/reference.html#gridlayer-minzoom\n   *\n   * @param {Object} zoomInput - is an element reference to a map-input[type=zoom]\n   * @returns {Object} - returns {minZoom: n,maxZoom: n,minNativeZoom: n,maxNativeZoom: n}\n   */\n  _getZoomBounds(zoomInput) {\n    // native variables should ONLY come from map-input min/max attributes\n    // BUT they should fall back to map-meta or projection values for min/max (display) zoom\n    // display zoom variables should be EQUAL to native unless specified differently\n    // via map-meta name=zoom\n    // in particular minNativeZoom being > minZoom can be problematic because\n    // you fetch tiles at larger scales (i.e. many many small tiles) and render\n    // them at smaller scale (i.e. little postage stamps), which can freez your\n    // browser and bury a tile cache in requests, getting you banned/blocked\n    //\n    // minZoom = map-meta name=zoom min || input type=zoom min || projection minZoom\n    // minNativeZoom = input type=zoom min || minZoom\n    // maxZoom = map-meta name=zoom max || input type=zoom max || projection maxZoom\n    // maxNativeZoom = input type=zoom max || maxZoom\n\n    let zoomBounds = {};\n    // search document from here up, using closest source of zoom bounds info\n    let meta = this.parentElement.getMeta('zoom');\n    let metaMin = meta\n      ? +M._metaContentToObject(meta.getAttribute('content'))?.min\n      : null;\n    zoomBounds.minZoom =\n      metaMin || (zoomInput ? +zoomInput.getAttribute('min') : 0);\n    zoomBounds.minNativeZoom = zoomInput\n      ? +zoomInput.getAttribute('min')\n      : zoomBounds.minZoom;\n    let metaMax = meta\n      ? +M._metaContentToObject(meta.getAttribute('content'))?.max\n      : null;\n    zoomBounds.maxZoom =\n      metaMax ||\n      (zoomInput\n        ? +zoomInput.getAttribute('max')\n        : M[this.parentElement.units].options.resolutions.length - 1);\n    zoomBounds.maxNativeZoom = zoomInput\n      ? +zoomInput.getAttribute('max')\n      : zoomBounds.maxZoom;\n\n    return zoomBounds;\n  }\n  _validateDisabled() {\n    let isVisible = false,\n      map = this.getMapEl(),\n      mapZoom = map.zoom,\n      extent = map.extent,\n      xmin = extent.topLeft.pcrs.horizontal,\n      xmax = extent.bottomRight.pcrs.horizontal,\n      ymin = extent.bottomRight.pcrs.vertical,\n      ymax = extent.topLeft.pcrs.vertical,\n      mapBounds = L.bounds(L.point(xmin, ymin), L.point(xmax, ymax));\n\n    if (this._templatedLayer) {\n      isVisible = this._templatedLayer.isVisible();\n    } else if (this.rel === 'query') {\n      const minZoom = this.extent.zoom.minZoom,\n        maxZoom = this.extent.zoom.maxZoom,\n        withinZoomBounds = (z) => {\n          return minZoom <= z && z <= maxZoom;\n        };\n\n      if (this.getBounds().overlaps(mapBounds) && withinZoomBounds(mapZoom)) {\n        isVisible = true;\n      }\n    }\n    return isVisible;\n  }\n  _createSelfOrStyleLink() {\n    let layerEl = this.getLayerEl();\n    const changeStyle = function (e) {\n      L.DomEvent.stop(e);\n      layerEl.dispatchEvent(\n        new CustomEvent('changestyle', {\n          detail: {\n            src: e.target.getAttribute('data-href'),\n            preference: this.media['prefers-map-content']\n          }\n        })\n      );\n    };\n\n    let styleOption = document.createElement('div'),\n      styleOptionInput = styleOption.appendChild(\n        document.createElement('input')\n      );\n    styleOptionInput.setAttribute('type', 'radio');\n    styleOptionInput.setAttribute('id', 'rad-' + L.stamp(styleOptionInput));\n    styleOptionInput.setAttribute(\n      'name',\n      // grouping radio buttons based on parent layer's style <detail>\n      'styles-' + L.stamp(styleOption)\n    );\n    styleOptionInput.setAttribute('value', this.getAttribute('title'));\n    styleOptionInput.setAttribute(\n      'data-href',\n      new URL(this.href, this.getBase()).href\n    );\n    var styleOptionLabel = styleOption.appendChild(\n      document.createElement('label')\n    );\n    styleOptionLabel.setAttribute('for', 'rad-' + L.stamp(styleOptionInput));\n    styleOptionLabel.innerText = this.title;\n    if (this.rel === 'style self' || this.rel === 'self style') {\n      styleOptionInput.checked = true;\n    }\n    this._styleOption = styleOption;\n    styleOptionInput.addEventListener('click', changeStyle.bind(this));\n  }\n  getLayerControlOption() {\n    return this._styleOption;\n  }\n\n  // Resolve the templated URL with info from the sibling map-input's\n  resolve() {\n    if (this.tref) {\n      let obj = {};\n      const inputs = this.parentElement.querySelectorAll('map-input');\n      if (this.rel === 'image') {\n        // image/map\n        for (let i = 0; i < inputs.length; i++) {\n          const inp = inputs[i];\n          obj[inp.name] = inp.value;\n        }\n        console.log(obj); // DEBUGGING\n        return L.Util.template(this.tref, obj);\n      } else if (this.rel === 'tile') {\n        // TODO. Need to get tile coords from moveend\n        // should be done/called from the TemplatedTilelayer.js file\n        return obj;\n      } else if (this.rel === 'query') {\n        // TODO. Need to get the click coords from click event\n        // should be done/called from the templatedlayer.js file\n      } else if (this.rel === 'features') {\n        // TODO.\n      }\n    }\n  }\n  whenReady() {\n    return new Promise((resolve, reject) => {\n      let interval, failureTimer, ready;\n      switch (this.rel.toLowerCase()) {\n        // for some cases, require a dependency check\n        case 'tile':\n        case 'image':\n        case 'features':\n          ready = '_templatedLayer';\n          break;\n        case 'style':\n        case 'self':\n        case 'style self':\n        case 'self style':\n          ready = '_styleOption';\n          break;\n        case 'query':\n          ready = 'shadowRoot';\n          break;\n        case 'alternate':\n          ready = '_alternate';\n          break;\n        case 'zoomin':\n        case 'zoomout':\n        case 'legend':\n        case 'stylesheet':\n        case 'license':\n          resolve();\n          break;\n        default:\n          resolve();\n          break;\n      }\n      if (this[ready]) {\n        resolve();\n      }\n      interval = setInterval(testForLinkReady, 300, this);\n      failureTimer = setTimeout(linkNotDefined, 10000);\n      function testForLinkReady(linkElement) {\n        if (linkElement[ready]) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          resolve();\n        } else if (!linkElement.isConnected) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          reject('map-link was disconnected while waiting to be ready');\n        }\n      }\n      function linkNotDefined() {\n        clearInterval(interval);\n        clearTimeout(failureTimer);\n        reject('Timeout reached waiting for link to be ready');\n      }\n    });\n  }\n}\n"],"names":["MapLink","HTMLElement","observedAttributes","#hasConnected","type","this","getAttribute","val","startsWith","setAttribute","rel","includes","href","hasAttribute","URL","getBase","resolve","hreflang","tref","M","BLANK_TT_TREF","media","_metaContentToObject","tms","projection","extent","_templateVars","Object","assign","_convertAndFormatPCRS","getBounds","parentExtent","units","zoom","getZoomBounds","zoomTo","let","map","getMapEl","_map","xmin","topLeft","pcrs","horizontal","xmax","bottomRight","ymin","vertical","ymax","bounds","L","point","center","options","crs","unproject","getCenter","maxZoom","minZoom","setView","getMaxZoom","animate","getClosest","node","selector","ShadowRoot","host","matches","parentNode","getLayerEl","attributeChangedCallback","name","oldValue","newValue","_initTemplateVars","constructor","super","connectedCallback","toLowerCase","_createTemplatedLink","_createSelfOrStyleLink","_createStylesheetLink","_createAlternateLink","disconnectedCallback","_stylesheetHost","link","remove","mapml","_alternate","source","target","getRootNode","parentElement","undefined","document","createElement","mapLink","Array","from","attributes","forEach","attribute","nodeName","nodeValue","_layer","appendStyleLink","_templatedLayer","toUpperCase","whenReady","inputsReady","error","console","log","mapEl","zIndex","querySelectorAll","indexOf","templatedTileLayer","zoomBounds","extentBounds","errorTileUrl","pane","_extentLayer","getContainer","linkEl","addTo","templatedImageLayer","attachShadow","mode","templatedFeaturesLayer","extend","_setupQueryVars","template","queryVarNames","query","inputs","values","i","length","axis","position","select","tagName","width","height","match","pixelleft","tileleft","mapleft","pixelright","tileright","mapright","pixeltop","tiletop","maptop","pixelbottom","tilebottom","mapbottom","tilei","mapi","tilej","mapj","parsedselect","htmlselect","value","input","linkedZoomInput","varNamesRe","RegExp","zoomInput","querySelector","includesZoom","v","vcount","exec","varName","inp","push","step","isNaN","decodeURI","Promise","allSettled","_getZoomBounds","zoomValue","boundsUnit","FALLBACK_CS","tilematrix","locInputs","max","min","axisToCS","x","horizontalAxis","y","verticalAxis","boundsToPCRSBounds","getFallbackBounds","metaExtent","getMeta","content","cs","metaKeys","keys","split","axes","csToAxes","layer","relativeURL","src","baseURI","baseURL","meta","metaMin","minNativeZoom","metaMax","resolutions","maxNativeZoom","_validateDisabled","isVisible","mapZoom","mapBounds","overlaps","z","layerEl","styleOption","styleOptionInput","appendChild","stamp","styleOptionLabel","innerText","title","checked","_styleOption","addEventListener","e","DomEvent","stop","dispatchEvent","CustomEvent","detail","preference","bind","getLayerControlOption","obj","Util","reject","interval","failureTimer","ready","setInterval","linkElement","clearInterval","clearTimeout","isConnected","setTimeout"],"mappings":"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"}